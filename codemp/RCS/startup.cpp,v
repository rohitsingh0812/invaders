head	1.5;
access;
symbols;
locks
	z7005034:1.5; strict;
comment	@// @;


1.5
date	2007.11.10.19.04.25;	author z7005034;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.09.13.49.16;	author z7005034;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.08.17.15.55;	author z7005034;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.07.14.48.42;	author z7005034;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.07.13.03.38;	author z7005034;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@#include"inclusionparts.h"
//rohit
double settingsLeftTopX =10.4091;
double settingsLeftTopY =1.77273;
double settingsRighBottomX =15.9545;
double settingsRightBottomY =3.54545;
//boundary x and y coordinates of settings button
double backLeftTopX =0.681818;
double backLeftTopY =16.2955;
double backRighBottomX =3.5;
double backRightBottomY =17.6364;
//boundary x and y coordinates of back button
double win4x=23.8,win4y=18.5;//stores boundary x and y coordinates for window W4
bool settingsWin=false;//stores whether settings window is active or not
color randomColor()
{
//generates a random color for statrtup animation (flying dots) using these six colors
	switch (rand()%6)
	{
		case 0 :
			return(Blue);
		case 1 :
 			return(Cyan);
		case 2 :
			return(Yellow);
		case 3 :
			return(Green);
		case 4 :
			return(Magenta);
		case 5 :
			return(Red);
	}
}
double calculateY(int i)
{
//manipulated y function for i'th dot(circle) so that its final position is the requisite value as stored in the 
//array showUpCentres 
	double xi=showUpCentres[i].GetXDistance();
	double yi=showUpCentres[i].GetYDistance();
	double x=(counter/NDIV)*xi*(1+4*sin(PI*x/xi)*sin(PI*(win4x-x)/xi));
	return(((0.0035*(xi-x)*(win4x-xi-x)*(i*i*sin(i*i)+1)/(NDIV-i))*sin(PI*x/xi)*sin(PI*(win4x-x)/xi))+yi);
	//sin ensures proper end coordinate from random appearing function
	
}
void showrectangles()
{
//shows eight rectangles around 4 menu operations
       	double pt[4][4];
       	fillup(pt);
       	createrectangle(pt[0],Black,Cyan);
       	createrectangle(pt[1],Blue,Yellow);
       	createrectangle(pt[2],Green,Black);
       	createrectangle(pt[3],Red,Yellow);
       	return;
}
void transform(double &x,double &y,int i)
{
//ensures that some dots fit into the window
	if(i%8!=0)
	return;
	if(x<=0 || x>=win4x)
	{
		x= (((int(x*10000 + x*x*2000))%10000)*(win4x-1)/10000.0) + x-int(x);
	}
	if(y<=0 || y>=win4y)
	{
		y= (((int(y*10000 + y*y*2000))%10000)*(win4y-1)/10000.0) + y-int(y);
	}
	return ;
}
int spltimer()
{
//timer function for animation(flying dots)
	if(counter==NDIV+1)
	{
		//stop the timer after calling it NDIV(constant) times
		sleep(1);
		stylishINV.Load("../images/title.xpm");
        	assert(stylishINV.GetStatus() == BitMapOkay);
        	stylishINV.SetPosition(Position(3.20912, 1.15909));
        	stylishINV.Draw();
		
		W4.RenderRectangle(Position(4.36364,7.36364),Position(20.6364,7.56364),Red,false);
		for(int i=0;i<NDOTS;i++)
        	{
       			double yco=showUpCentres[i].GetYDistance();
       			double xco=showUpCentres[i].GetXDistance();

       			CircleShape C(W4,Position(xco,yco),randomColor(),0.15);
			C.Draw();
        	}
        	W4.StopTimer();
        	loadingWindow();
        	return 1;
	}
       	W4.RenderRectangle(Position(0,0),Position(win4x,win4y),Black,false);
        
        
	for(int i=0;i<NDOTS;i++)
        {
       		double yco=calculateY(i);
       		double xco;
       		double xi=showUpCentres[i].GetXDistance();
       		xco=counter*showUpCentres[i].GetXDistance()/NDIV;
       		if(i%2==1)
       		xco=(win4x*(NDIV-counter)/NDIV+counter*(showUpCentres[i].GetXDistance())/NDIV);
		xco=xco*(1+4*sin(PI*xco/xi)*sin(PI*(win4x-xco)/xi));
		transform(xco,yco,i);
       		CircleShape C(W4,Position(xco,yco),randomColor(),0.15);
		C.Draw();
		
        }
        W4.RenderText(Position(11.9,12.0),"",Yellow,Red);
        counter++;
        
}
void invadersShowUp()
{
	W4.Open();
	W4.RenderRectangle(Position(0,0),Position(win4x,win4y),Black,false);
        for(int i=0;i<NDOTS;i++)
        {
       		double X,Y;
		fcentres>>X>>Y;
        	showUpCentres[i]=Position(X,Y);
        }
        W4.SetTimerCallback(spltimer);
        W4.StartTimer(7);
}
void loadingWindow()
{
	int nFiles=26;
	ifstream f1("../data/jpg.txt");
	ifstream f2("../data/xpm.txt");
	double d=100.00/nFiles;
	//string strload="Loading 0 %";
	//W4.RenderText(Position(11.9,12.0),strload,Yellow,Red);
	loadBmp.Load("../images/loading.xpm");
        assert(loadBmp.GetStatus() == BitMapOkay);
       	loadBmp.SetPosition(Position(8.4, 9));
       	loadBmp.Draw();
	W4.RenderRectangle(Position(5.9,13),Position(17.9,13.4),Red,true);
	W4.RenderText(Position(11.9,12.0),"",Yellow,Red);
	string jpg;
	string xpm;
	for(int i=0;i<nFiles;i++)
	{

		f1>>jpg;
		f2>>xpm;
		string t ="convert "+jpg+" "+xpm;
		system(t.c_str());
		//string strload="Loading " + itoa(ceil(d*(i+1)))+" %";
		//W4.RenderText(Position(11.9,12.0),strload,Yellow,Red);
		double xCoOrd=5.9 +12.0*ceil(d*(i+1))/100.0;
		W4.RenderRectangle(Position(5.9,13),Position(xCoOrd,13.4),Blue,false);
		W4.RenderText(Position(11.9,12.0),"",Yellow,Red);
	}
	startup();
}
void setUpCountries()
{
	if(map==0)
	{
		ifstream fcircles("../data/countrycircles.txt");
		for(int i=0;i<NCountry;i++)
		{
			double x,y;
			fcircles>>x>>y>>diameters[i];
			centers[i]=Position(x,y);
		}
	}
	if(map==1)
	{
		ifstream fcircles("../data/countrycircles2.txt");
		for(int i=0;i<NCountry;i++)
		{
			int c;
			double x,y,d;
			fcircles>>c>>x>>y>>d;
			diameters[c]=d;
			centers[c]=Position(x,y);
		}
	}

}
void gameproceed()
{
	setUpCountries();
	W1.Open();
	focus=1;
        assert(W1.GetStatus() == WindowOpen);
        if(map==0)
        {
		W1Bmp.Load("../images/World.xpm");
	}
	else
	{
		W1Bmp.Load("../images/World2.xpm");
	}
	W1Bmp2.Load("../images/lr.xpm");
	W1Bmp3.Load("../images/ud.xpm");
	W1Bmp4.Load("../images/lr.xpm");
	W1Bmp5.Load("../images/ud.xpm");
        assert(W1Bmp.GetStatus() == BitMapOkay);
        W1Bmp.SetPosition(Position(0.25, 0.5));
        W1Bmp2.SetPosition(Position(0, 0));
        W1Bmp3.SetPosition(Position(0, 0));
        W1Bmp4.SetPosition(Position(28.9,0));
        W1Bmp5.SetPosition(Position(0, 19.4));
        W1Bmp2.Draw();
        W1Bmp3.Draw();
        W1Bmp4.Draw();
        W1Bmp5.Draw();
        W1Bmp.Draw();
        W1.RenderText(Position(15,19.8),spaces(194),Yellow,Red);
	if(loaded==0)
	{	
		int gamemap[NCountry];
		int soldiers[NCountry];
	        randomdist(gamemap,soldiers);
		for(int i=0;i<NCountry;i++)
	        {
	                all[i].ownership=gamemap[i];
	                all[i].nos = soldiers[i];
		}
		
	}
	if(multiplayer)
	strComp="Player 2";
        PrintPhase();
	ShowEndTurn();
	ShowSaveGame();
	ShowMainMenu();
	refreshLines();
        refresh2();
        PrintLeft("   You haven't selected any country   ");
	PrintRein();
        getclick();

}
void createrectangle(double a[4],color cl1,color cl2)
{
	Position myp[4]={Position(a[0],a[1]),Position(a[0],a[2]),Position(a[3],a[2]),Position(a[3],a[1])};
        Position myq[4]={Position(a[0]-0.2,a[1]-0.2),Position(a[0]-0.2,a[2]-0.2),Position(a[3]-0.2,a[2]-0.2),Position(a[3]-0.2,a[1]-0.2)};
        for(int i=0;i<4;i++)
        {
        	W4.RenderLine(myp[i],myp[(i+1)%4],cl1,0.05);
        	W4.RenderLine(myq[i],myq[(i+1)%4],cl2,0.05);
        }
}
void fillup(double pt[4][4])
{
	  double x1=4.96,x2=11.25,y1=4.85,y2=6.3;
        pt[0][0]=x1;
        pt[0][1]=y1;
        pt[0][2]=y2;
        pt[0][3]=x2;
        for(int i=1;i<=3;i++)
        {
       		pt[i][0]=pt[i-1][0]+3.0;
        	pt[i][1]=pt[i-1][1]+2.2;
        	pt[i][2]=pt[i-1][2]+2.2;
        	pt[i][3]=pt[i-1][3]+3.0;
        	
        }
}
void startup()
{
	if(W4.GetStatus() != WindowOpen)
	W4.Open();
	loaded=0;
	ls="load";
        assert(W4.GetStatus() == WindowOpen);
	W4.RenderRectangle(Position(0,0),Position(win4x,win4y),Black,false);
        W4Bmp.Load("../images/31.xpm");
        assert(W4Bmp.GetStatus() == BitMapOkay);
        W4Bmp.SetPosition(Position(0.25, 0.5));
        W4Bmp.Draw();
	showrectangles();
	W4.SetMouseClickCallback(f);
        return;
}
Position easy=Position(1.88636,6.63636);
Position medium=Position(1.88636,8.15909);
Position hard=Position(1.90909,9.59091);
Position HVsC=Position(13.5,7.18182);
Position HVsH=Position(13.5,8.40909);
Position mapOld=Position(3,14.4773);
Position mapNew=Position(13.7045,14.6136);
Position distrP=Position(12.1364,10.5682);
Position distrC=Position(16.6591,10.6136);
bool clickedInside(Position p,Position check)
{
        double x=p.GetXDistance();
        double y=p.GetYDistance();
        double xc=check.GetXDistance();
        double yc=check.GetYDistance();
        if(fabs(x-xc)<=0.2 && fabs(y-yc)<=0.2)
        return true;
        else
        return false;
}
void drawCheck(Position p)
{
	CircleShape C(W4,p,Black,0.15);
	C.Draw();	
}
void removeCheck(Position p)
{
	CircleShape C(W4,p,White,0.15);
	C.Draw();	
}
int settingsClick(const Position& p)
{
        double x=p.GetXDistance();
        double y=p.GetYDistance();
	if(x>=backLeftTopX && y>=backLeftTopY && x<=backRighBottomX && y<=backRightBottomY)
        {
        	startup();
        	settingsWin=false;
        	return 1;
        }
        if(clickedInside(p,easy))
        {
        	level=0;
        	drawCheck(easy);
        	removeCheck(medium);
        	removeCheck(hard);
        }
        if(clickedInside(p,medium))
        {
        	level=1;
        	removeCheck(easy);
        	drawCheck(medium);
        	removeCheck(hard);
        }
        if(clickedInside(p,hard))
        {
        	level=2;
        	removeCheck(easy);
        	removeCheck(medium);
        	drawCheck(hard);
        }
        if(clickedInside(p,HVsC))
        {
        	multiplayer = false;
        	removeCheck(HVsH);
        	drawCheck(HVsC);
        }
        if(clickedInside(p,HVsH))
        {
        	multiplayer=true;
        	removeCheck(HVsC);
        	drawCheck(HVsH);
        }
        if(clickedInside(p,mapOld))
        {
        	map=0;
        	removeCheck(mapNew);
        	drawCheck(mapOld);
        }
        if(clickedInside(p,mapNew))
        {
        	map=1;
        	removeCheck(mapOld);
        	drawCheck(mapNew);
        }
        if(clickedInside(p,distrP))
        {
        	redistr=0;
        	removeCheck(distrC);
        	drawCheck(distrP);
        }
        if(clickedInside(p,distrC))
        {
        	redistr=1;
        	removeCheck(distrP);
        	drawCheck(distrC);
        }
        //cout<<"("<<p.GetXDistance()<<","<<p.GetYDistance()<<")"<<multiplayer<<"\t"<<level<<"\t"<<map<<endl;
        return 1;
}
int mouseClickFocus4(const Position& p)
{
	double pt[4][4];
        fillup(pt);
        double x=p.GetXDistance();
        double y=p.GetYDistance();
        //cout<<"Position("<<x<<","<<y<<")"<<endl;
        if(settingsWin==true)
        {
        	settingsClick(p);
        	return 1;
        }
        if(x>=settingsLeftTopX && y>=settingsLeftTopY && x<=settingsRighBottomX && y<=settingsRightBottomY)
        {
        	W4Bmp.Load("../images/3.xpm");
        	assert(W4Bmp.GetStatus() == BitMapOkay);
        	W4Bmp.SetPosition(Position(0.25, 0.5));
        	W4Bmp.Draw();
        	settingsWin=true;
        	removeCheck(easy);
        	removeCheck(medium);
        	removeCheck(hard);
        	if(level==0)
        		drawCheck(easy);
        	if(level==1)
        		drawCheck(medium);
        	if(level==2)
        		drawCheck(hard);
        	removeCheck(HVsC);
        	removeCheck(HVsH);
        	if(multiplayer==false)
        		drawCheck(HVsC);
        	if(multiplayer==true)
        		drawCheck(HVsH);
        	removeCheck(mapOld);
        	removeCheck(mapNew);
        	if(map==0)
        	drawCheck(mapOld);
        	if(map==1)
        	drawCheck(mapNew);
        	removeCheck(distrP);
        	removeCheck(distrC);
        	if(map==0)
        	drawCheck(distrP);
        	if(map==1)
        	drawCheck(distrC);
        	return 1;
        }

        if(x>=pt[0][0] && x<=(pt[0][3]-.2) && y>=pt[0][1] && y<=(pt[0][2]-.2))
        {
        //play game
        	createrectangle(pt[0],Blue,Black);
        	W4.RenderText(Position(0,0),"",Yellow,Red);
        	usleep(150000);
        	createrectangle(pt[0],Yellow,Red);
        	W4.RenderText(Position(0,0),"",Yellow,Red);
        	usleep(150000);
		gameproceed();
		W4Bmp.Erase();
		W4.Close();
		return 1;
	}
	if(x>=pt[1][0] && x<=(pt[1][3]-.2) && y>=pt[1][1] && y<=(pt[1][2]-.2))
        {
	//how to play
	}
	if(x>=pt[2][0] && x<=(pt[2][3]-.2) && y>=pt[2][1] && y<=(pt[2][2]-.2))
        {
	//load game
        	createrectangle(pt[2],Blue,Black);
        	W4.RenderText(Position(0,0),"",Yellow,Red);
        	usleep(150000);
        	createrectangle(pt[2],Yellow,Red);
        	W4.RenderText(Position(0,0),"",Yellow,Red);
        	usleep(150000);
		ls="load";
		showsave();
		W4Bmp.Erase();
		W4.Close();
	}
	if(x>=pt[3][0] && x<=(pt[3][3]-.2) && y>=pt[3][1] && y<=(pt[3][2]-.2))
        {
	//quit
		createrectangle(pt[3],Black,Yellow);
        	W4.RenderText(Position(0,0),"",Yellow,Red);
        	usleep(150000);
        	createrectangle(pt[3],Black,Blue);
        	W4.RenderText(Position(0,0),"",Yellow,Red);
        	usleep(150000);
		W4Bmp.Erase();
		W4.Close();
		showmsg.msg="Thank You for Playing Invaders...";
		showmsg.show();
	}
	return 0;
}
@


1.4
log
@attack2
@
text
@d2 1
d7 1
d12 3
a14 1
bool settingsWin=false;
d17 1
d36 2
d40 3
a42 3
	double x=(counter/NDIV)*xi*(1+4*sin(PI*x/xi)*sin(PI*(23.8-x)/xi));
	return(((0.0035*(xi-x)*(23.8-xi-x)*(i*i*sin(i*i)+1)/(NDIV-i))*sin(PI*x/xi)*sin(PI*(23.8-x)/xi))+yi);
	
d47 1
d56 1
a56 1
void transform(double &x,double &y)
d58 4
a61 2

	if(x<=0 || x>=23.8)
d63 1
a63 1
		x= (((int(x*10000))%10000)*22.8/10000.0) + x-int(x);
d65 1
a65 1
	if(y<=0 || y>=18.5)
d67 1
a67 1
		y= (((int(y*10000))%10000)*17.5/10000.0) + y-int(y);
d69 1
d73 1
d76 1
d96 1
a96 1
       	W4.RenderRectangle(Position(0,0),Position(23.8,18.5),Black,false);
d106 3
a108 3
       		xco=(23.8*(NDIV-counter)/NDIV+counter*(showUpCentres[i].GetXDistance())/NDIV);
		xco=xco*(1+4*sin(PI*xco/xi)*sin(PI*(23.8-xco)/xi));
		//transform(xco,yco);
d120 1
a120 1
	W4.RenderRectangle(Position(0,0),Position(23.8,18.5),Black,false);
a158 1
	sleep(1);
d275 1
a275 1
	W4.RenderRectangle(Position(0,0),Position(23.8,18.5),Black,false);
d291 2
d306 1
a306 1
	CircleShape C(W4,p,Black,0.1);
d311 1
a311 1
	CircleShape C(W4,p,White,0.1);
d314 70
a385 1

d390 1
d393 1
a393 52
        	if(x>=backLeftTopX && y>=backLeftTopY && x<=backRighBottomX && y<=backRightBottomY)
        	{
        		startup();
        		settingsWin=false;
        		return 1;
        	}
        	if(clickedInside(p,easy))
        	{
        		level=0;
        		drawCheck(easy);
        		removeCheck(medium);
        		removeCheck(hard);
        	}
        	if(clickedInside(p,medium))
        	{
        		level=1;
        		removeCheck(easy);
        		drawCheck(medium);
        		removeCheck(hard);
        	}
        	if(clickedInside(p,hard))
        	{
        		level=2;
        		removeCheck(easy);
        		removeCheck(medium);
        		drawCheck(hard);
        	}
        	if(clickedInside(p,HVsC))
        	{
        		multiplayer = false;
        		removeCheck(HVsH);
        		drawCheck(HVsC);
        	}
        	if(clickedInside(p,HVsH))
        	{
        		multiplayer=true;
        		removeCheck(HVsC);
        		drawCheck(HVsH);
        	}
        	if(clickedInside(p,mapOld))
        	{
        		map=0;
        		removeCheck(mapNew);
        		drawCheck(mapOld);
        	}
        	if(clickedInside(p,mapNew))
        	{
        		map=1;
        		removeCheck(mapOld);
        		drawCheck(mapNew);
        	}
        	//cout<<"("<<p.GetXDistance()<<","<<p.GetYDistance()<<")"<<multiplayer<<"\t"<<level<<"\t"<<map<<endl;
d424 6
@


1.3
log
@2nd
@
text
@d173 1
d223 1
d360 1
a360 1
        	cout<<"("<<p.GetXDistance()<<","<<p.GetYDistance()<<")"<<multiplayer<<"\t"<<level<<"\t"<<map<<endl;
@


1.2
log
@twenty seventh
@
text
@d2 9
a10 1
double xD=23.75;
d38 1
a38 2

int animate()
d40 7
a46 34
	
	if(xD<=0.25)
	{
        	W4.StopTimer();
        	double pt[4][4];
        	fillup(pt);
        	createrectangle(pt[0],Black,Cyan);
        	createrectangle(pt[1],Blue,Yellow);
        	createrectangle(pt[2],Green,Black);
        	createrectangle(pt[3],Red,Yellow);
	        W4.SetMouseClickCallback(f);
        	return 0;
        	
        }
        /*
        //sliding from right
        W4Bmp.SetPosition(Position(xD, 0.5));
        W4Bmp.Draw();
        if(xD<1)
        {
        	xD=0.25;
        	return 0;
        }
        xD-=1;
        */
        //sliding from left
        W4Bmp.SetPosition(Position(23.8-xD, 0.5));
        W4Bmp.Draw();
        if(xD<1)
        {
        	xD=0.25;
        	return 0;
        }
        xD-=1;
d50 1
a50 2
	if(rand()%3==0)
	return;
d95 1
a95 1
		transform(xco,yco);
d119 1
a119 1
	
d122 1
a122 1
	double d=100.00/24.00;
d133 1
a133 1
	for(int i=0;i<24;i++)
a141 1
		
d149 25
d176 1
a176 1
	
d180 8
a187 1
	W1Bmp.Load("../images/World.xpm");
d226 1
d256 1
d258 1
a258 1
	xD=23.75;
d264 33
a296 3
	W4.SetTimerCallback(animate);
        W4.StartTimer(20);

d300 1
d305 87
d404 1
@


1.1
log
@Initial revision
@
text
@d2 1
d30 51
d116 1
d236 1
a236 1
        	pt[i][0]=pt[i-1][0]+3.0;
d246 1
a248 1
        W4.SetMouseClickCallback(f);
d252 2
a253 10

        W4Bmp.SetPosition(Position(0.25, 0.5));
        W4Bmp.Draw();
        double pt[4][4];
        fillup(pt);
        createrectangle(pt[0],Black,Cyan);
        
        createrectangle(pt[1],Blue,Yellow);
        createrectangle(pt[2],Green,Black);
        createrectangle(pt[3],Red,Yellow);
@
